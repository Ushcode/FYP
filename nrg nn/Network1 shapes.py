#!/usr/bin/python

"""
This Network is trained with 10,000 points generated by TASK1_triangle, AND 10,000 points generated by TASK1_line The data is NORMALISED before splitting into training, val, test sets. Each set contains half from the line data and half from triangle data
"""
plum = '#A16E83'
blu = '#206B99'

from keras.models import Sequential, load_model
from keras.layers import Dense, Activation
from keras.callbacks import EarlyStopping, ModelCheckpoint
from keras import metrics
import matplotlib.pyplot as plt
plt.style.use('seaborn')
import numpy as np
import random

datalist = np.load("/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/Data/normal1.npy")
nrglist = np.load("/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/Data/nrg_normal1.npy")

datalist_lin = np.load("/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/Data/normal1_line.npy")
nrglist_lin = np.load("/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/Data/nrg_normal1_line.npy")

"""
__________BAD DON'T TOUCH___________
# Normalise input vector
x_mu = np.mean(datalist, axis=0)
x_std = np.std(datalist, axis=0)
datalist_NORM = (datalist - x_mu)/x_std

x_mu_lin = np.mean(datalist_lin, axis=0)
x_std_lin = np.std(datalist_lin, axis=0)
datalist_lin_NORM = (datalist_lin - x_mu_lin)/x_std_lin

#normalise energies
y_mu = np.mean(nrglist)
y_std = np.std(nrglist)
nrglist_NORM = (nrglist - y_mu)/y_std

y_mu_lin = np.mean(nrglist_lin)
y_std_lin = np.std(nrglist_lin)
nrglist_lin_NORM = (nrglist_lin - y_mu_lin)/y_std_lin
"""

x = list(datalist_lin) #lines
xx  = list( datalist) #triangles
y = list(nrglist_lin)
yy = list(nrglist)


xxx = xx + x  #triangles then lines
yyy = yy + y  #"


"""
PROBLEM ONE
"""

#random.shuffle(xxx)
#random.shuffle(yyy)

#plt.figure()
#plt.style.use('ggplot')
#plt.plot(xxx)
#plt.plot(xxx)
#plt.title("Arrangement of three Particles")
#plt.show()



# Normalise input vector
x_mu = np.mean(xxx, axis=0)
x_std = np.std(xxx, axis=0)
datalist_NORM = (xxx - x_mu)/x_std

#normalise energies
y_mu = np.mean(yyy)
y_std = np.std(yyy)
nrglist_NORM = (yyy - y_mu)/y_std


"""
SHOULD BE RIGHT
"""
x = datalist_NORM[:10000] #lines
xx = datalist_NORM[10000:20000] #triangles

y = nrglist_NORM[:10000]
yy  = nrglist_NORM[10000:20000]

train = x[:6000] + xx[:6000]
#random.shuffle(train)
val = x[6000:8000] + xx[6000:8000]
#random.shuffle(val)
test = x[8000:10000] + xx[8000:10000]
#random.shuffle(test)

ytrain = y[:6000] + yy[:6000]
#random.shuffle(ytrain)
yval = y[6000:8000] + yy[6000:8000]
#random.shuffle(yval)
ytest = y[8000:10000] + yy[8000:10000]
#random.shuffle(ytest)



"""
SHOULD BE WRONG
"""

train = xxx[:12000]
#random.shuffle(train)
val = xxx[12000:16000]
#random.shuffle(val)
test = xxx[16000:20000]
#random.shuffle(test)

ytrain = yyy[:12000]
#random.shuffle(ytrain)
yval = yyy[12000:16000]
#random.shuffle(yval)
ytest = yyy[16000:20000]
#random.shuffle(ytest)


#Split into training, validation and test sets

datalist_train = np.asarray(train)
datalist_val = np.asarray(val)
datalist_test = np.asarray(test)

nrglist_train = np.asarray(ytrain)
nrglist_val = np.asarray(yval)
nrglist_test = np.asarray(ytest)

print (datalist_train.shape)
print (nrglist_train.shape)


#Create model
model = Sequential([
    Dense(64, input_shape = (3,)),
    Activation('relu'),
    Dense(32),
    Activation('relu'),
    Dense(1),
])

# Compile model
model.compile(optimizer = 'adam', loss = 'mse')

callbacks = [EarlyStopping(patience=100, verbose=1), ModelCheckpoint(filepath='/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/Trained Networks/model1_shapes_a.h5', save_best_only=True, verbose=1)]

# Save the model with the modelcheckpoint callback (callbacks are fns carried out during training to monitor progress

print(model.summary())


# Train
epochs = 500

history = model.fit(x=datalist_train, y=nrglist_train, epochs=epochs, validation_data=(datalist_val, nrglist_val), batch_size=32,  verbose = 1, callbacks = callbacks)



#  Test Error
pred_test = model.predict(datalist_test).flatten()
mae_error = np.mean(np.abs(pred_test-nrglist_test)) # mean absolute error
print("Generalization Error (MAE): %f" % mae_error)

"""
# plot accuracy
plt.figure()
plt.plot(history.history['acc'], label='Train')
plt.plot(history.history['val_acc'], label='Validation')
plt.title('Model accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(loc='upper left')
"""

# plot loss
plt.figure()
plt.plot(history.history['loss'], label='Train', color=plum)
plt.plot(history.history['val_loss'], label='Validation', color=blu)
plt.title('Model loss (MSE)')
plt.ylabel('Loss')
plt.yscale('log')
plt.xlabel('Epoch')
plt.legend()
plt.savefig('/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/figs/lossshapes.eps', bbox_inches='tight')

# plot predictions vs true values
plt.figure()
p_min = np.min([pred_test, nrglist_test])
p_max = np.max([pred_test, nrglist_test])
plt.plot([p_min,p_max], [p_min,p_max], linestyle='dashed', color='k')

plt.scatter(pred_test, nrglist_test, color = plum)
plt.xlabel('Prediction')
plt.ylabel('True')
plt.title('Test Set Predictions, MAE=%.3f' % mae_error)
plt.savefig('/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/figs/netshapesbtr.eps', bbox_inches='tight')

plt.show()
