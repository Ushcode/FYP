#!/usr/bin/python

"""
This Network is trained with 10,000 points generated by TASK1_triangle, AND 10,000 points generated by TASK1_line The data is NORMALISED before splitting into training, val, test sets. Each set contains half from the line data and half from triangle data
"""
plum = '#A16E83'
blu = '#206B99'

from keras.models import Sequential, load_model
from keras.layers import Dense, Activation
from keras.callbacks import EarlyStopping, ModelCheckpoint
from keras import metrics
import matplotlib.pyplot as plt
plt.style.use('ggplot')
import numpy as np
import random

datalist_tri = np.load("/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/Data/uniform1.npy")
nrglist_tri = np.load("/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/Data/nrg_uniform1.npy")

datalist_lin = np.load("/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/Data/uniform1_line.npy")
nrglist_lin = np.load("/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/Data/nrg_uniform1_line.npy")


x = list(datalist_lin) #make em lists
xx  = list(datalist_tri)
y = list(nrglist_lin)
yy = list(nrglist_tri)

xxx = x + xx #combine
yyy = y + yy

#random.shuffle(xxx) #shuffle
#random.shuffle(yyy)

## Normalise input vector
#x_mu = np.mean(xxx, axis=0)
#x_std = np.std(xxx, axis=0)
#datalist_NORM = (xxx - x_mu)/x_std
#
##normalise energies
#y_mu = np.mean(yyy)
#y_std = np.std(yyy)
#nrglist_NORM = (yyy - y_mu)/y_std

#Split into training, validation and test sets

#################
# SHOULD BE WRONG
#################

#train = xxx[:12000]
#val = xxx[12000:16000]
#test = xxx[16000:20000]
#
#ytrain = yyy[:12000]
#yval = yyy[12000:16000]
#ytest = yyy[16000:20000]

#################
# SHOULD BE RIGHT
#################

#x = datalist_NORM[:10000] #lines
#xx = datalist_NORM[10000:20000] #triangles
#
#y = nrglist_NORM[:10000]
#yy  = nrglist_NORM[10000:20000]

train = x[:6000] + xx[:6000]
#random.shuffle(train)
val = x[6000:8000] + xx[6000:8000]
#random.shuffle(val)
test = x[8000:10000] + xx[8000:10000]
#random.shuffle(test)

ytrain = y[:6000] + yy[:6000]
#random.shuffle(ytrain)
yval = y[6000:8000] + yy[6000:8000]
#random.shuffle(yval)
ytest = y[8000:10000] + yy[8000:10000]
#random.shuffle(ytest)

datalist_train = np.asarray(train)
datalist_val = np.asarray(val)
datalist_test = np.asarray(test)

nrglist_train = np.asarray(ytrain)
nrglist_val = np.asarray(yval)
nrglist_test = np.asarray(ytest)

print (datalist_train.shape)
print (nrglist_train.shape)




#Create model
model = Sequential([
    Dense(64, input_shape = (3,)),
    Activation('relu'),
    Dense(32),
    Activation('relu'),
    Dense(1),
])

# Compile model
model.compile(optimizer = 'adam', loss = 'mse')

callbacks = [EarlyStopping(patience=50, verbose=1), ModelCheckpoint(filepath='/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/Trained Networks/model1_shapes.h5', save_best_only=True, verbose=1)]

# Save the model with the modelcheckpoint callback (callbacks are fns carried out during training to monitor progress

print(model.summary())


# Train
epochs = 1200

history = model.fit(x=datalist_train, y=nrglist_train, epochs=epochs, validation_data=(datalist_val, nrglist_val), batch_size=32,  verbose = 1, callbacks = callbacks)



#  Test Error
pred_test = model.predict(datalist_test).flatten()
mae_error = np.mean(np.abs(pred_test-nrglist_test)) # mean absolute error
print("Generalization Error (MAE): %f" % mae_error)

"""
# plot accuracy
plt.figure()
plt.plot(history.history['acc'], label='Train')
plt.plot(history.history['val_acc'], label='Validation')
plt.title('Model accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(loc='upper left')
"""

# plot loss
plt.figure()
plt.plot(history.history['loss'], label='Train', color=plum)
plt.plot(history.history['val_loss'], label='Validation', color=blu)
plt.title('Model loss (MSE)')
plt.ylabel('Loss')
plt.yscale('log')
plt.xlabel('Epoch')
plt.legend()
plt.savefig('/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/figs/lossshapesbtr.eps', bbox_inches='tight')

# plot predictions vs true values
plt.figure()
p_min = np.min([pred_test, nrglist_test])
p_max = np.max([pred_test, nrglist_test])
plt.plot([p_min,p_max], [p_min,p_max], linestyle='dashed', color='k')

plt.scatter(pred_test, nrglist_test, color = plum)
plt.xlabel('Prediction')
plt.ylabel('True')
plt.title('Test Set Predictions, MAE=%.3f' % mae_error)
plt.savefig('/Users/Oisin/Documents/Theoretical Physics/PROJECT/CODE/figs/netshapesbtr.eps', bbox_inches='tight')

plt.show()

